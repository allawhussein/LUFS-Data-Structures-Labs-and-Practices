Q1

void moveHeadToLast(node **headRef)
{
    // your code goes here
    if(headRef == NULL || *headRef == NULL || (*headRef)->next == NULL) return;
    if((*headRef)->next->next == NULL)
    {
        node *temp = (*headRef)->next;
        (*headRef)->next->next = *headRef;
        (*headRef)->next = NULL;
        *headRef = temp;
        return;
    }
    node *second = (*headRef)->next;
    node *temp = (*headRef)->next->next;
    (*headRef)->next->next = *headRef;
    (*headRef)->next = temp;
    (*headRef) = second;
    moveHeadToLast(&((*headRef)->next));
    
}

Q2


node *addNumbersHelper(node *head1, node *head2)
{
    // your code goes here
    if(head1 == NULL || head2 == NULL) return NULL;
    node *newNode = (node*)malloc(sizeof(node));
    int data = head1->data + head2->data;
    newNode->data = data;
    newNode->next = addNumbersHelper(head1->next, head2->next);
    if(newNode->next)
    {
        if(newNode->next->data > 9)
        {
            newNode->data += newNode->next->data/10;
            newNode->next->data %= 10;
        }
    }
    return newNode;
}
node *addNumbers(node *head1, node *head2)
{
    if(head1 == NULL || head2 == NULL) return NULL;
    node *head = addNumbersHelper(head1,head2);
    if(head->data > 9)
    {
        node *newNode = (node*)malloc(sizeof(node));
        newNode->data = head->data/10;
        newNode->next = head;
        head->data %= 10; 
        return newNode;
    }
    return head;
}



Q3




int toDecimalHelper(node *head, int sum)
{
    if(head->next == NULL)
    {
        return sum*2+head->data;
    }
    sum = sum*2+head->data;
    return toDecimalHelper(head->next, sum);
}
int toDecimal(node *head)
{
    // your code goes here
    if(head == NULL) return 0;
    return toDecimalHelper(head, 0);
}




Q4



int isBalancedHelper(char str[], int i, int sum)
{
    if(str[i] == '\0') return sum;
    if(str[i] == '(') sum += 1;
    if(str[i] == ')') sum -= 1;
    if(sum<0) return -1;
    return isBalancedHelper(str, ++i, sum);
    
}
int isBalanced(char str[])
{
   // your code goes here
   if(isBalancedHelper(str,0,0) == 0) return 1;
   return 0;
}






Q5




int countReversalsHelper(char *str, int i, int count, int sum)
{
    if(*(str+i) == '\0')
    {
        if(i%2 == 1) return -1;
        return count+sum/2;
    }
    if(*(str+i) == '(')
    {
        sum+=1;
    }
    if(*(str+i) == ')')
    {
        if(sum == 0)
        {
            count++;
            sum += 1;
        }
        else sum-=1;
    }
    return countReversalsHelper(str, ++i, count, sum);
}

int countReversals(char *str)
{
    // your code goes here
    return countReversalsHelper(str, 0,0, 0);
}





Q6




char *convert(int num, int base, char *str)
{
   // your code goes here
   if(base < 2 || num <= 0)
   {
       *str = '0';
       *(str+1) = '\0';
       return str;
   }
   if(num == 0)
    {
        return str;
    }
   str = convert(num/base, base,str);
   if(num%base > 9)
    {
        *str = 'A' + num%base - 10;
        *(str+1) = '\0';
    }
    else
    {
        *str = '0' +num%base;
        *(str+1) = '\0';
    }
   return str+1;
}




Q7




void reorder(node **headRef)
{
    if(!headRef || !*headRef || !((*headRef)->next))
        return;
    //calculating number of nodes
    node *ptr = *headRef;
    int size,i;
    for (size=0; ptr; ptr=ptr->next)
        size++;

    //organazing the Linked Lists in Two new ones
    node *head1=NULL, *head2=NULL;
    node **head1Ref=&head1, **head2Ref=&head2;

    //tail Push For The First Half of the LL To head1
    for (i = 0; i < size/2; i++)
    {
        *head1Ref = *headRef;
        head1Ref = &((*head1Ref)->next);
        *headRef = (*headRef)->next;
    }
     *head1Ref = NULL;

    node * ter = NULL;
     //Normal Push For The Second Half of the LL To head2
     for(i=size/2; i<size ; i++)
     {
         ter = *headRef;
         *headRef = (*headRef)->next;
         ter -> next = *head2Ref;
         *head2Ref = ter;
     }

    *headRef = NULL;
     while (head1 || head2)
     {
         if(head2)
         {
             *headRef = head2;
             head2 = head2->next;
             (*headRef)->next = NULL;
             headRef = &((*headRef)->next);
         }

         if(head1)
         {
             *headRef = head1;
             head1 = head1->next;
             (*headRef)->next = NULL;
             headRef = &((*headRef)->next);
         }
     }
}



Q8





int isBalancedHelper(char *str, int i, int sum1,int sum2, int sum3, int type)
{
    if(*(str+i) == '\0')
    {
        if(sum1 == 0 && sum2 == 0 && sum3 == 0) return 0;
        else return 1;
    }
    if(*(str+i) == '(')
    {
        if(sum1 == 0 && sum2 == 0 && sum3 == 0) type = 0;
        sum1 += 1;
    }    
    if(*(str+i) == ')') sum1 -= 1;
    if(*(str+i) == '{')
    {
        if(sum1 == 0 && sum2 == 0 && sum3 == 0) type = 1;
        sum2 += 1;
    }
    if(*(str+i) == '}') sum2 -= 1;
    if(*(str+i) == '[')
    {
        if(sum1 == 0 && sum2 == 0 && sum3 == 0) type = 2;
        sum3 += 1;
    }    
    if(*(str+i) == ']') sum3 -= 1;
    if(sum1<0) return -1;
    if(sum2<0) return -1;
    if(sum3<0) return -1;
    if(type == 0 && sum1 == 0 && (sum2 != 0 || sum3 != 0)) return -1;
    if(type == 1 && sum2 == 0 && (sum1 != 0 || sum3 != 0)) return -1;
    if(type == 2 && sum3 == 0 && (sum2 != 0 || sum1 != 0)) return -1;
    return isBalancedHelper(str, ++i, sum1, sum2, sum3, type);
    
}
int isBalanced(char *str)
{
   // your code goes here
   if(isBalancedHelper(str,0,0,0,0,0) == 0) return 1;
   return 0;
}







Q9





void Push(row **sparseRef, entry *newEntry, int row_num)
{
    if(*sparseRef == NULL)
    {
        row *newRow = (row*)malloc(sizeof(row));
        newRow->row_num = row_num;
        newRow->start = newEntry;
        newRow->next = NULL;
        *sparseRef = newRow;
        return;
    }
    for(row *cur_row = *sparseRef ; cur_row ; cur_row = cur_row->next)
    {
        entry *prevEntry = NULL;
        if(cur_row->row_num == row_num)
        {
            for(entry *cur_entry = cur_row->start ;  ; cur_entry = cur_entry->next)
            {
                if(newEntry->col_num < cur_entry->col_num)
                {
                    if(prevEntry == NULL)
                    {
                        cur_row->start = newEntry;
                        return;
                    }
                    else
                    {
                        newEntry->next = cur_entry;
                        prevEntry->next = newEntry;
                        return;
                    }
                }
                if(cur_entry->next == NULL)
                {
                    cur_entry->next = newEntry;
                    return;
                }
                prevEntry = cur_entry;
            }
        }
    }
    row *newRow = (row*)malloc(sizeof(row));
    newRow->row_num = row_num;
    newRow->start = newEntry;
    newRow->next = NULL;
    row *prevRow = NULL;
    for(row *cur_row = *sparseRef ; cur_row ; cur_row = cur_row->next)
    {
        if(newRow->row_num < cur_row->row_num)
        {
            if(prevRow == NULL)
            {
                newRow->next = *sparseRef;
                *sparseRef = newRow;
                return;
            }
            else
            {
                newRow->next = cur_row;
                prevRow->next = newRow;
                return;
            }
        }
        if(cur_row->next == NULL)
        {
            cur_row->next = newRow;
            return;
        }
        prevRow = cur_row;
    }
}

void transpose(row **sparseRef)
{
    // your code goes here
    row **headRef = (row**)malloc(sizeof(row*));
    row *head = NULL;
    *headRef = head;
    row *cur_row = *sparseRef;
    entry *cur_col;
    for( ; cur_row ; cur_row = cur_row->next)
    {
        for(cur_col = cur_row->start ; cur_col ; cur_col = cur_col->next)
        {
            entry *newEntry = (entry*)malloc(sizeof(entry));
            newEntry->data = cur_col->data;
            newEntry->col_num = cur_row->row_num;
            newEntry->next = NULL;
            Push(headRef, newEntry, cur_col->col_num);
        }
    }
    *sparseRef = *headRef;
}